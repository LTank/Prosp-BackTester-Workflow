# -*- coding: utf-8 -*-
"""10fruits10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rKkZFFTDt897f0k78-Xcq_KaO4RMOYN2
"""

# -*- coding: utf-8 -*-
"""Starfruit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xXHJYTISHkiACQsLPvwOlB64M8s21Tnu
"""

# -*- coding: utf-8 -*-
"""Starfruit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xXHJYTISHkiACQsLPvwOlB64M8s21Tnu
"""

# -*- coding: utf-8 -*-
"""Starfruit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xXHJYTISHkiACQsLPvwOlB64M8s21Tnu
"""

# -*- coding: utf-8 -*-
"""Starfruit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xXHJYTISHkiACQsLPvwOlB64M8s21Tnu
"""

from datamodel import OrderDepth, UserId, TradingState, Order
from typing import List
import string
import pandas as pd

class Trader:
    starfruit_cache = []
    last_value = 0
    counter = 0
    cache_len = 8 #1 more than coef

    def calc_next_price_starfruit(self):

            intercept = .004
            coef = [-0.02640914, -0.07974619, -0.1503525 , -0.24380195, -0.35047668, -0.49547579, -0.70531434]
            diffs = pd.Series(self.starfruit_cache).diff(1)[1:]

            nxt_price = self.starfruit_cache[-1] + intercept

            for i, val in enumerate(diffs):
                diff =  val * coef[i]
                nxt_price += diff

            return nxt_price


    def run(self, state: TradingState):
        self.counter += 1

        print("traderData: " + state.traderData)
        print("Observations: " + str(state.observations))

        result = {}

        for product in state.order_depths:
          if product == 'STARFRUIT':
            order_depth: OrderDepth = state.order_depths[product]
            orders: List[Order] = []
            position: int = state.position.get(product, 0)
            max_buy = 20 - position
            max_sell = -20 - position
            starfruit_lb, starfruit_ub = 0,0
            pricevol = 0
            vol = 0
            print("POSITION", position)



# ###MANAGE NEXT CALCULATION

#             if len(order_depth.sell_orders) != 0:
#                 best_ask, best_ask_amount = list(order_depth.sell_orders.items())[0]

#             if len(order_depth.buy_orders) != 0:
#                 best_bid, best_bid_amount = list(order_depth.buy_orders.items())[0]
            sells = list(order_depth.sell_orders.items())

            buys = list(order_depth.buy_orders.items())
            if len(buys) == 1:
                best_bid = buys[0][0]
            elif len(buys) == 2:
                best_bid = buys[1][0]
            else:
                best_bid = buys[2][0]


            if len(sells) == 1:
                best_ask = sells[0][0]
            elif len(sells) == 2:
                best_ask = sells[1][0]
            else:
                best_ask = sells[2][0]

            mid_price = (best_ask + best_bid)/2
            # print("MID PRICE", mid_price)
            self.starfruit_cache.append(mid_price)
            self.last_value = mid_price

            starfruit_fair = 0

            # print("STARFRUIT CACHE", self.starfruit_cache)

            if len(self.starfruit_cache) == self.cache_len:
                starfruit_fair = self.calc_next_price_starfruit()
                # print("NEXT FAIR PRICE", starfruit_fair)
                self.starfruit_cache.pop(0)

            if self.counter >= 5:
                # starfruit_fair = np.average(self.starfruit_cache)


                if len(order_depth.sell_orders) != 0:
                    for ask, amount in list(order_depth.sell_orders.items()):
                        if int(ask) < starfruit_fair:
                            buy_volume = max(min(-amount, max_buy), 0)
                            print("BUY", str(-buy_volume) + "x", ask)
                            orders.append(Order(product, ask, buy_volume))
                            max_buy = max_buy - buy_volume
                            position = position + buy_volume

                if len(order_depth.buy_orders) != 0:
                    for bid, amount in list(order_depth.buy_orders.items()):
                        if int(bid) > starfruit_fair:
                            sell_volume = min(max(-amount, max_sell), 0)
                            print("SELL", str(sell_volume) + "x", bid)
                            orders.append(Order(product, bid, sell_volume))
                            max_sell = max_sell - sell_volume
                            position = position + sell_volume

            delta = 4

            acceptable_price = 0
            total_amount = 0

            if len(order_depth.sell_orders) != 0:
                for ask, amount in list(order_depth.sell_orders.items()):
                    acceptable_price += abs(ask * amount)
                    total_amount += abs(amount)
            if len(order_depth.buy_orders) != 0:
                for bid, amount in list(order_depth.buy_orders.items()):
                    acceptable_price += abs(bid * amount)
                    total_amount += abs(amount)
            acceptable_price = int(acceptable_price/total_amount)



            if len(order_depth.sell_orders) != 0:
              sell_threshold = list(order_depth.sell_orders.items())[-1][0]
              orders.append(Order(product, sell_threshold - 1, max_sell))
            if len(order_depth.buy_orders) != 0:
              buy_threshold = list(order_depth.buy_orders.items())[-1][0]
              orders.append(Order(product, buy_threshold + 1, max_buy))


            result[product] = orders

		    # String value holding Trader state data required.
				# It will be delivered as TradingState.traderData on next execution.
        traderData = "SAMPLE"

				# Sample conversion request. Check more details below.
        conversions = 0
        return result, conversions, traderData